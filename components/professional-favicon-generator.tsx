"use client"

import type React from "react"
import { useState, useCallback, useRef, useEffect } from "react"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Checkbox } from "@/components/ui/checkbox"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Slider } from "@/components/ui/slider"
import { Badge } from "@/components/ui/badge"
import { Progress } from "@/components/ui/progress"
import { ScrollArea } from "@/components/ui/scroll-area"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"
import {
  UploadCloud,
  Settings,
  Download,
  Eye,
  Copy,
  Check,
  Smartphone,
  Monitor,
  Bookmark,
  Search,
  Zap,
  Package,
  Palette,
  Sliders,
  FolderOpen,
  Grid,
  Code,
  Sun,
  Contrast,
  Droplets,
  CropIcon,
  RefreshCcw,
  ArrowRight,
} from "lucide-react"
import { useToast } from "@/hooks/use-toast"
import {
  COMPREHENSIVE_FAVICON_SIZES,
  generateComprehensiveFavicons,
  generateComprehensiveHTMLCode,
  generateAdvancedManifest,
  loadImageFromFile,
  type AdvancedProcessingOptions,
  type FaviconResult,
  type GenerationProgress,
  type CropShapeParams,
  cropAndShapeImage,
} from "@/lib/advanced-favicon-utils"
import { FAVICON_TEMPLATES, type FaviconTemplate } from "@/lib/template-gallery"
import { ColorPaletteManager } from "@/lib/color-palette-manager"

const CROP_PREVIEW_MAX_SIZE = 300
const RESIZE_HANDLE_SIZE = 10

type ResizeHandle =
  | "top-left"
  | "top-right"
  | "bottom-left"
  | "bottom-right"
  | "top"
  | "bottom"
  | "left"
  | "right"
  | null

const INITIAL_PROCESSING_OPTIONS: Omit<AdvancedProcessingOptions, "cropShapeParams"> = {
  backgroundColor: "#FFFFFF",
  borderColor: "#000000",
  hasBorder: false,
  borderWidth: 1,
  borderRadius: 0,
  filter: "none",
  brightness: 100,
  contrast: 100,
  saturation: 100,
  quality: 0.9,
  format: "png",
  compression: 80,
  effects: {
    shadow: false,
    shadowColor: "#000000",
    shadowBlur: 4,
    shadowOffset: { x: 2, y: 2 },
    glow: false,
    glowColor: "#FFFFFF",
    glowIntensity: 50,
  },
}

type Props = {}

const ProfessionalFaviconGenerator: React.FC<Props> = () => {
  const { toast } = useToast()
  const fileInputRef = useRef<HTMLInputElement>(null)
  const cropSelectionCanvasRef = useRef<HTMLCanvasElement | null>(null)
  const cropPreviewCanvasRef = useRef<HTMLCanvasElement | null>(null)

  const [uploadedFile, setUploadedFile] = useState<File | null>(null)
  const [sourceCanvas, setSourceCanvas] = useState<HTMLCanvasElement | null>(null)
  const [previewUrl, setPreviewUrl] = useState<string | null>(null)
  const [isProcessing, setIsProcessing] = useState(false)
  const [processingProgress, setProcessingProgress] = useState<GenerationProgress | null>(null)

  const [faviconResults, setFaviconResults] = useState<FaviconResult[]>([])
  const [manifestContent, setManifestContent] = useState<string>("")
  const [htmlCode, setHtmlCode] = useState<string>("")

  const [cropRectangleSettings, setCropRectangleSettings] = useState({
    x: 0,
    y: 0,
    width: 256,
    height: 256,
    cornerRadius: 0,
  })

  const [activeDragAction, setActiveDragAction] = useState<"move" | "resize" | null>(null)
  const [activeResizeHandle, setActiveResizeHandle] = useState<ResizeHandle>(null)
  const [dragStartPos, setDragStartPos] = useState<{ x: number; y: number } | null>(null)
  const [initialCropOnDrag, setInitialCropOnDrag] = useState<typeof cropRectangleSettings | null>(null)
  const [currentCursor, setCurrentCursor] = useState<string>("grab")

  const [processingOptions, setProcessingOptions] = useState<AdvancedProcessingOptions>(INITIAL_PROCESSING_OPTIONS)
  const [hasBackgroundColor, setHasBackgroundColor] = useState<boolean>(true)

  const [appConfig, setAppConfig] = useState({
    name: "My Favicon App",
    description: "Generated by Professional Favicon Generator",
    themeColor: "#3B82F6",
    keywords: ["favicon", "icon", "generator"],
    author: "CognifyTech",
    siteUrl: "https://cognifytech.in/tool",
  })
  const [activeTab, setActiveTab] = useState("upload")
  const [previewMode, setPreviewMode] = useState<"browser" | "mobile" | "bookmark" | "search">("browser")
  const [isDraggingOverFile, setIsDraggingOverFile] = useState(false)
  const [copied, setCopied] = useState(false)
  const [showTemplateGallery, setShowTemplateGallery] = useState(false)
  const [selectedSizes, setSelectedSizes] = useState<number[]>(
    COMPREHENSIVE_FAVICON_SIZES.filter((s) => s.recommended).map((s) => s.size),
  )

  const tabOrder: string[] = ["upload", "customize", "generate", "download"]

  const handleNextTab = () => {
    const currentIndex = tabOrder.indexOf(activeTab)
    if (currentIndex < tabOrder.length - 1) {
      const nextTab = tabOrder[currentIndex + 1]
      if (nextTab) {
        if (nextTab === "customize" && !sourceCanvas) {
          toast({ title: "Please upload an image first.", variant: "warning" })
          return
        }
        if ((nextTab === "advanced" || nextTab === "generate") && !sourceCanvas) {
          toast({ title: "Please upload an image first.", variant: "warning" })
          return
        }
        setActiveTab(nextTab)
      }
    }
  }

  useEffect(() => {
    // setColorPalettes(ColorPaletteManager.getAllPalettes()); // If needed for UI
  }, [])

  useEffect(() => {
    if (sourceCanvas) {
      setCropRectangleSettings({ x: 0, y: 0, width: sourceCanvas.width, height: sourceCanvas.height, cornerRadius: 0 })
    }
  }, [sourceCanvas])

  const resetCropToFullImageDimensions = useCallback(() => {
    if (sourceCanvas) {
      setCropRectangleSettings({ x: 0, y: 0, width: sourceCanvas.width, height: sourceCanvas.height, cornerRadius: 0 })
      toast({ title: "Crop Reset", description: "Crop area reset to full image dimensions." })
    }
  }, [sourceCanvas, toast])

  const validateAndFixCropSettings = useCallback(
    (newSettings: typeof cropRectangleSettings) => {
      if (!sourceCanvas) return newSettings

      let { x, y, width, height, cornerRadius } = newSettings

      // Ensure minimum dimensions
      width = Math.max(10, width)
      height = Math.max(10, height)

      // Ensure within canvas bounds
      width = Math.min(width, sourceCanvas.width)
      height = Math.min(height, sourceCanvas.height)
      x = Math.max(0, Math.min(x, sourceCanvas.width - width))
      y = Math.max(0, Math.min(y, sourceCanvas.height - height))

      // Adjust dimensions if position pushes them out of bounds
      width = Math.min(width, sourceCanvas.width - x)
      height = Math.min(height, sourceCanvas.height - y)

      // Ensure corner radius is valid
      cornerRadius = Math.max(0, Math.min(cornerRadius, width / 2, height / 2))

      return { x, y, width, height, cornerRadius }
    },
    [sourceCanvas],
  )

  // Update crop selection canvas (shows overlay)
  useEffect(() => {
    const canvas = cropSelectionCanvasRef.current
    const ctx = canvas?.getContext("2d")
    if (!ctx || !canvas || !sourceCanvas) {
      if (canvas && ctx) ctx.clearRect(0, 0, canvas.width, canvas.height)
      return
    }

    const dpr = typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1
    let displayWidth = sourceCanvas.width,
      displayHeight = sourceCanvas.height

    // Scale down for display if needed
    if (displayWidth > CROP_PREVIEW_MAX_SIZE) {
      const r = CROP_PREVIEW_MAX_SIZE / displayWidth
      displayWidth = CROP_PREVIEW_MAX_SIZE
      displayHeight *= r
    }
    if (displayHeight > CROP_PREVIEW_MAX_SIZE) {
      const r = CROP_PREVIEW_MAX_SIZE / displayHeight
      displayHeight = CROP_PREVIEW_MAX_SIZE
      displayWidth *= r
    }

    displayWidth = Math.max(1, displayWidth)
    displayHeight = Math.max(1, displayHeight)
    canvas.width = displayWidth * dpr
    canvas.height = displayHeight * dpr
    canvas.style.width = `${displayWidth}px`
    canvas.style.height = `${displayHeight}px`
    ctx.scale(dpr, dpr)
    ctx.clearRect(0, 0, displayWidth, displayHeight)

    // Draw source image
    ctx.drawImage(sourceCanvas, 0, 0, sourceCanvas.width, sourceCanvas.height, 0, 0, displayWidth, displayHeight)

    // Calculate display scaling factors
    const scaleX = displayWidth / sourceCanvas.width
    const scaleY = displayHeight / sourceCanvas.height

    // Draw crop selection overlay
    const { x, y, width, height, cornerRadius } = cropRectangleSettings
    const sX = x * scaleX
    const sY = y * scaleY
    const sW = width * scaleX
    const sH = height * scaleY
    const sR = Math.min(cornerRadius * Math.min(scaleX, scaleY), sW / 2, sH / 2)

    // Draw semi-transparent overlay on non-selected areas
    ctx.fillStyle = "rgba(0, 0, 0, 0.5)"
    ctx.fillRect(0, 0, displayWidth, displayHeight)

    // Clear the selected area
    ctx.globalCompositeOperation = "destination-out"
    ctx.beginPath()
    ctx.roundRect(sX, sY, sW, sH, sR)
    ctx.fill()

    // Draw selection border
    ctx.globalCompositeOperation = "source-over"
    ctx.strokeStyle = "rgba(0, 120, 255, 0.9)"
    ctx.lineWidth = 2
    ctx.beginPath()
    ctx.roundRect(sX, sY, sW, sH, sR)
    ctx.stroke()

    // Draw resize handles if dragging
    if (activeDragAction === "resize" || activeDragAction === "move") {
      const handleSize = RESIZE_HANDLE_SIZE / 2
      ctx.fillStyle = "rgba(0, 120, 255, 0.8)"
      ctx.fillRect(sX - handleSize, sY - handleSize, handleSize * 2, handleSize * 2)
      ctx.fillRect(sX + sW - handleSize, sY - handleSize, handleSize * 2, handleSize * 2)
      ctx.fillRect(sX - handleSize, sY + sH - handleSize, handleSize * 2, handleSize * 2)
      ctx.fillRect(sX + sW - handleSize, sY + sH - handleSize, handleSize * 2, handleSize * 2)
    }
  }, [sourceCanvas, cropRectangleSettings, activeDragAction])

  // Update crop preview canvas (shows actual cropped result)
  useEffect(() => {
    const canvas = cropPreviewCanvasRef.current
    const ctx = canvas?.getContext("2d")
    if (!ctx || !canvas || !sourceCanvas) {
      if (canvas && ctx) ctx.clearRect(0, 0, canvas.width, canvas.height)
      return
    }

    try {
      // Generate actual crop preview using same function as final output
      const cropParams: CropShapeParams = { shape: "rectangle", ...cropRectangleSettings }
      const croppedCanvas = cropAndShapeImage(sourceCanvas, cropParams)

      // Set preview canvas size to show the cropped result
      const previewSize = 128
      canvas.width = previewSize
      canvas.height = previewSize
      canvas.style.width = `${previewSize}px`
      canvas.style.height = `${previewSize}px`

      ctx.clearRect(0, 0, previewSize, previewSize)

      // Apply background if enabled
      if (hasBackgroundColor && processingOptions.backgroundColor !== "transparent") {
        ctx.fillStyle = processingOptions.backgroundColor || "#FFFFFF"
        ctx.fillRect(0, 0, previewSize, previewSize)
      }

      // Calculate scaling to fit cropped image in preview
      const scale = Math.min(previewSize / croppedCanvas.width, previewSize / croppedCanvas.height)
      const scaledWidth = croppedCanvas.width * scale
      const scaledHeight = croppedCanvas.height * scale
      const xOffset = (previewSize - scaledWidth) / 2
      const yOffset = (previewSize - scaledHeight) / 2

      // Draw the cropped image
      ctx.drawImage(croppedCanvas, xOffset, yOffset, scaledWidth, scaledHeight)

      // Convert to data URL for preview
      setPreviewUrl(canvas.toDataURL("image/png", 0.9))
    } catch (error) {
      console.error("Crop preview generation error:", error)
      setPreviewUrl("/preview-error.png")
    }
  }, [sourceCanvas, cropRectangleSettings, processingOptions.backgroundColor, hasBackgroundColor])

  const handleFileUpload = useCallback(
    async (file: File) => {
      if (!file) return
      if (file.size > 10 * 1024 * 1024) {
        toast({ title: "File too large", description: "Max 10MB.", variant: "destructive" })
        return
      }
      if (!file.type.startsWith("image/")) {
        toast({ title: "Invalid file type", description: "Use PNG, JPG, SVG, WebP.", variant: "destructive" })
        return
      }
      setUploadedFile(file)
      setIsProcessing(true)
      setProcessingProgress({ current: 1, total: 3, stage: "Loading image...", percentage: 33 })
      try {
        const canvas = await loadImageFromFile(file)
        setSourceCanvas(canvas)
        const extractedColors = ColorPaletteManager.extractColorsFromImage(canvas)
        if (extractedColors.length > 0 && extractedColors[0])
          setProcessingOptions((prev) => ({ ...prev, backgroundColor: extractedColors[0] as string }))
        setProcessingProgress({ current: 3, total: 3, stage: "Image loaded!", percentage: 100 })
        setActiveTab("customize")
        toast({ title: "Image uploaded!", description: "Customize your favicon." })
      } catch (error: any) {
        toast({ title: "Upload Failed", description: error.message || "Could not load image.", variant: "destructive" })
        console.error("Upload failed:", error)
      } finally {
        setIsProcessing(false)
        setProcessingProgress(null)
      }
    },
    [toast],
  )

  const handleRectangleCropChange = (field: keyof typeof cropRectangleSettings, value: string | number) => {
    if (!sourceCanvas) return
    const rawNumValue = typeof value === "string" ? Number.parseInt(value, 10) : value
    if (isNaN(rawNumValue) && typeof value === "string" && value.trim() !== "") {
      toast({ title: "Invalid Input", description: `Enter number for ${field}.`, variant: "warning" })
      return
    }
    const numValue = isNaN(rawNumValue)
      ? field === "cornerRadius"
        ? 0
        : field === "width" || field === "height"
          ? 10
          : 0
      : rawNumValue

    const newSettings = { ...cropRectangleSettings, [field]: numValue }
    const validatedSettings = validateAndFixCropSettings(newSettings)
    setCropRectangleSettings(validatedSettings)
  }

  const getScaleFactors = useCallback(() => {
    if (!sourceCanvas || !cropSelectionCanvasRef.current)
      return { displayToSourceX: 1, displayToSourceY: 1, sourceToDisplayX: 1, sourceToDisplayY: 1 }
    const canvas = cropSelectionCanvasRef.current
    const displayWidth = Number.parseFloat(canvas.style.width || "0")
    const displayHeight = Number.parseFloat(canvas.style.height || "0")
    if (displayWidth === 0 || displayHeight === 0 || sourceCanvas.width === 0 || sourceCanvas.height === 0)
      return { displayToSourceX: 1, displayToSourceY: 1, sourceToDisplayX: 1, sourceToDisplayY: 1 }
    return {
      displayToSourceX: sourceCanvas.width / displayWidth,
      displayToSourceY: sourceCanvas.height / displayHeight,
      sourceToDisplayX: displayWidth / sourceCanvas.width,
      sourceToDisplayY: displayHeight / sourceCanvas.height,
    }
  }, [sourceCanvas])

  const getHandleAtPosition = useCallback(
    (clientX: number, clientY: number): ResizeHandle => {
      if (!sourceCanvas || !cropSelectionCanvasRef.current) return null
      const canvasEl = cropSelectionCanvasRef.current
      const rect = canvasEl.getBoundingClientRect()
      const mouseX = clientX - rect.left
      const mouseY = clientY - rect.top
      const { sourceToDisplayX, sourceToDisplayY } = getScaleFactors()
      const { x, y, width, height } = cropRectangleSettings
      const dispX = x * sourceToDisplayX,
        dispY = y * sourceToDisplayY,
        dispW = width * sourceToDisplayX,
        dispH = height * sourceToDisplayY
      const handleArea = RESIZE_HANDLE_SIZE
      if (Math.abs(mouseX - dispX) < handleArea && Math.abs(mouseY - dispY) < handleArea) return "top-left"
      if (Math.abs(mouseX - (dispX + dispW)) < handleArea && Math.abs(mouseY - dispY) < handleArea) return "top-right"
      if (Math.abs(mouseX - dispX) < handleArea && Math.abs(mouseY - (dispY + dispH)) < handleArea) return "bottom-left"
      if (Math.abs(mouseX - (dispX + dispW)) < handleArea && Math.abs(mouseY - (dispY + dispH)) < handleArea)
        return "bottom-right"
      if (Math.abs(mouseY - dispY) < handleArea && mouseX > dispX + handleArea && mouseX < dispX + dispW - handleArea)
        return "top"
      if (
        Math.abs(mouseY - (dispY + dispH)) < handleArea &&
        mouseX > dispX + handleArea &&
        mouseX < dispX + dispW - handleArea
      )
        return "bottom"
      if (Math.abs(mouseX - dispX) < handleArea && mouseY > dispY + handleArea && mouseY < dispY + dispH - handleArea)
        return "left"
      if (
        Math.abs(mouseX - (dispX + dispW)) < handleArea &&
        mouseY > dispY + handleArea &&
        mouseY < dispY + dispH - handleArea
      )
        return "right"
      return null
    },
    [cropRectangleSettings, getScaleFactors, sourceCanvas],
  )

  const handleInteractionStart = useCallback(
    (clientX: number, clientY: number) => {
      if (!sourceCanvas || !cropSelectionCanvasRef.current) return
      const handle = getHandleAtPosition(clientX, clientY)
      setDragStartPos({ x: clientX, y: clientY })
      setInitialCropOnDrag({ ...cropRectangleSettings })
      if (handle) {
        setActiveDragAction("resize")
        setActiveResizeHandle(handle)
      } else {
        const canvasEl = cropSelectionCanvasRef.current
        const rect = canvasEl.getBoundingClientRect()
        const localX = clientX - rect.left,
          localY = clientY - rect.top
        const { sourceToDisplayX, sourceToDisplayY } = getScaleFactors()
        const { x: cropX, y: cropY, width: cropW, height: cropH } = cropRectangleSettings
        const dispX = cropX * sourceToDisplayX,
          dispY = cropY * sourceToDisplayY,
          dispW = cropW * sourceToDisplayX,
          dispH = cropH * sourceToDisplayY
        if (localX >= dispX && localX <= dispX + dispW && localY >= dispY && localY <= dispY + dispH) {
          setActiveDragAction("move")
          setCurrentCursor("grabbing")
        }
      }
    },
    [sourceCanvas, cropRectangleSettings, getHandleAtPosition, getScaleFactors],
  )

  const handleCropMouseDown = (e: React.MouseEvent<HTMLDivElement>) => handleInteractionStart(e.clientX, e.clientY)
  const handleCropTouchStart = (e: React.TouchEvent<HTMLDivElement>) => {
    if (e.touches.length === 1 && e.touches[0]) {
      e.preventDefault()
      handleInteractionStart(e.touches[0].clientX, e.touches[0].clientY)
    }
  }

  const handleInteractionMove = useCallback(
    (clientX: number, clientY: number) => {
      if (!activeDragAction || !dragStartPos || !initialCropOnDrag || !sourceCanvas) return
      const { displayToSourceX, displayToSourceY } = getScaleFactors()
      const deltaX = (clientX - dragStartPos.x) * displayToSourceX
      const deltaY = (clientY - dragStartPos.y) * displayToSourceY
      let { x, y, width, height, cornerRadius } = initialCropOnDrag
      if (activeDragAction === "move") {
        x += deltaX
        y += deltaY
      } else if (activeDragAction === "resize" && activeResizeHandle) {
        switch (activeResizeHandle) {
          case "top-left":
            x += deltaX
            y += deltaY
            width -= deltaX
            height -= deltaY
            break
          case "top-right":
            y += deltaY
            width += deltaX
            height -= deltaY
            break
          case "bottom-left":
            x += deltaX
            width -= deltaX
            height += deltaY
            break
          case "bottom-right":
            width += deltaX
            height += deltaY
            break
          case "top":
            y += deltaY
            height -= deltaY
            break
          case "bottom":
            height += deltaY
            break
          case "left":
            x += deltaX
            width -= deltaX
            break
          case "right":
            width += deltaX
            break
        }
        const minDim = RESIZE_HANDLE_SIZE * displayToSourceX * 2
        if (width < minDim) {
          if (activeResizeHandle.includes("left")) x = initialCropOnDrag.x + initialCropOnDrag.width - minDim
          width = minDim
        }
        if (height < minDim) {
          if (activeResizeHandle.includes("top")) y = initialCropOnDrag.y + initialCropOnDrag.height - minDim
          height = minDim
        }
      }

      const newSettings = { x, y, width, height, cornerRadius }
      const validatedSettings = validateAndFixCropSettings(newSettings)
      setCropRectangleSettings(validatedSettings)
    },
    [
      activeDragAction,
      dragStartPos,
      initialCropOnDrag,
      sourceCanvas,
      activeResizeHandle,
      getScaleFactors,
      validateAndFixCropSettings,
    ],
  )

  const handleInteractionEnd = useCallback(() => {
    if (activeDragAction) {
      setActiveDragAction(null)
      setActiveResizeHandle(null)
    }
  }, [activeDragAction])

  useEffect(() => {
    const moveListener = (e: MouseEvent) => handleInteractionMove(e.clientX, e.clientY)
    const touchMoveListener = (e: TouchEvent) => {
      if (e.touches.length === 1 && e.touches[0]) {
        e.preventDefault()
        handleInteractionMove(e.touches[0].clientX, e.touches[0].clientY)
      }
    }
    if (activeDragAction) {
      document.addEventListener("mousemove", moveListener)
      document.addEventListener("mouseup", handleInteractionEnd)
      document.addEventListener("touchmove", touchMoveListener, { passive: false })
      document.addEventListener("touchend", handleInteractionEnd)
      document.addEventListener("touchcancel", handleInteractionEnd)
    }
    return () => {
      document.removeEventListener("mousemove", moveListener)
      document.removeEventListener("mouseup", handleInteractionEnd)
      document.removeEventListener("touchmove", touchMoveListener)
      document.removeEventListener("touchend", handleInteractionEnd)
      document.removeEventListener("touchcancel", handleInteractionEnd)
    }
  }, [activeDragAction, handleInteractionMove, handleInteractionEnd])

  const handleCropCanvasMouseMoveForCursor = (e: React.MouseEvent<HTMLDivElement>) => {
    if (activeDragAction) return
    const handle = getHandleAtPosition(e.clientX, e.clientY)
    let newCursor = "grab"
    if (handle) {
      switch (handle) {
        case "top-left":
        case "bottom-right":
          newCursor = "nwse-resize"
          break
        case "top-right":
        case "bottom-left":
          newCursor = "nesw-resize"
          break
        case "top":
        case "bottom":
          newCursor = "ns-resize"
          break
        case "left":
        case "right":
          newCursor = "ew-resize"
          break
      }
    } else {
      const canvasEl = cropSelectionCanvasRef.current
      if (!canvasEl) {
        setCurrentCursor("default")
        return
      }
      const rect = canvasEl.getBoundingClientRect()
      const mouseX = e.clientX - rect.left,
        mouseY = e.clientY - rect.top
      const { sourceToDisplayX, sourceToDisplayY } = getScaleFactors()
      const { x: cropX, y: cropY, width: cropW, height: cropH } = cropRectangleSettings
      const dispX = cropX * sourceToDisplayX,
        dispY = cropY * sourceToDisplayY,
        dispW = cropW * sourceToDisplayX,
        dispH = cropH * sourceToDisplayY
      if (mouseX >= dispX && mouseX <= dispX + dispW && mouseY >= dispY && mouseY <= dispY + dispH) newCursor = "grab"
      else newCursor = "default"
    }
    setCurrentCursor(newCursor)
  }

  const handleGenerate = async () => {
    if (!sourceCanvas) {
      toast({ title: "No Image Uploaded", description: "Upload image first.", variant: "destructive" })
      return
    }
    if (selectedSizes.length === 0) {
      toast({ title: "No Sizes Selected", description: "Select at least one size.", variant: "destructive" })
      return
    }
    setIsProcessing(true)
    setProcessingProgress(null)
    try {
      const finalCropParams: CropShapeParams = { shape: "rectangle", ...cropRectangleSettings }
      const finalBackgroundColorForGeneration = hasBackgroundColor ? processingOptions.backgroundColor : "transparent"
      const finalBackgroundColorForManifest = hasBackgroundColor
        ? processingOptions.backgroundColor || "#FFFFFF"
        : "#FFFFFF" // PWA manifest usually needs a color
      const currentProcessingOptions: AdvancedProcessingOptions = {
        ...processingOptions,
        cropShapeParams: finalCropParams,
        backgroundColor: finalBackgroundColorForGeneration, // Updated
      }
      const results = await generateComprehensiveFavicons(
        sourceCanvas,
        selectedSizes,
        currentProcessingOptions,
        setProcessingProgress,
      )
      if (results.length === 0 && selectedSizes.length > 0) throw new Error("No favicons generated.")
      setFaviconResults(results)
      setHtmlCode(generateComprehensiveHTMLCode(appConfig.name, appConfig.themeColor))
      setManifestContent(
        JSON.stringify(
          generateAdvancedManifest(
            appConfig.name,
            appConfig.themeColor,
            finalBackgroundColorForManifest, // Updated
            appConfig.description,
          ),
          null,
          2,
        ),
      )
      setActiveTab("download")
      fetch("/api/stats/track", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ action: "generate", count: results.length }),
      }).catch(console.error)
      toast({ title: "Favicons Generated!", description: `${results.length} favicons ready.` })
    } catch (error: any) {
      toast({
        title: "Generation Error",
        description: error.message || "Failed to generate.",
        variant: "destructive",
        duration: 9000,
      })
      console.error("Generation failure:", error)
    } finally {
      setIsProcessing(false)
    }
  }

  const handleDrop = useCallback(
    (e: React.DragEvent) => {
      e.preventDefault()
      setIsDraggingOverFile(false)
      const files = Array.from(e.dataTransfer.files)
      if (files.length > 0 && files[0]) handleFileUpload(files[0])
    },
    [handleFileUpload],
  )
  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault()
    setIsDraggingOverFile(true)
  }, [])
  const handleDragLeave = useCallback((e: React.DragEvent) => {
    e.preventDefault()
    setIsDraggingOverFile(false)
  }, [])
  const handleSizeToggle = (size: number, checked: boolean) =>
    setSelectedSizes((prev) => (checked ? [...prev, size].sort((a, b) => a - b) : prev.filter((s) => s !== size)))

  const copyToClipboard = async (text: string, type: string) => {
    if (!navigator.clipboard) {
      // Fallback for browsers without Clipboard API (e.g., insecure contexts)
      try {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed"; // Prevent scrolling to bottom of page in MS Edge.
        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.width = "2em";
        textArea.style.height = "2em";
        textArea.style.padding = "0";
        textArea.style.border = "none";
        textArea.style.outline = "none";
        textArea.style.boxShadow = "none";
        textArea.style.background = "transparent";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        const successful = document.execCommand("copy");
        document.body.removeChild(textArea);
        if (successful) {
          toast({ title: `${type} Copied!`, description: `${type} copied (fallback).` });
          setCopied(true);
          setTimeout(() => setCopied(false), 2000);
        } else {
          throw new Error("Fallback copy command failed");
        }
      } catch (err) {
        toast({ title: `Copy Failed`, description: `Could not copy ${type.toLowerCase()} using fallback.`, variant: "destructive" });
        console.error(`Fallback Copy ${type} failed:`, err);
      }
      return;
    }

    // Modern Clipboard API approach
    try {
      await navigator.clipboard.writeText(text);
      toast({ title: `${type} Copied!`, description: `${type} copied.` });
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      toast({ title: `Copy Failed`, description: `Could not copy ${type.toLowerCase()}. Ensure permissions are granted.`, variant: "destructive" });
      console.error(`Copy ${type} failed:`, err);
    }
  };

  const downloadFile = (url: string, filename: string) => {
    try {
      const link = document.createElement("a");
      link.href = url;
      link.download = filename; // Ensure download attribute is set
      link.target = "_blank"; // Helps on some browsers
      link.rel = "noopener noreferrer";

      // Append, click, and remove the link
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      // Clean up blob URL after a delay
      if (url.startsWith("blob:")) {
        setTimeout(() => URL.revokeObjectURL(url), 3000); // Increased delay slightly
      }
    } catch (error) {
      console.error("Download failed:", error);
      toast({
        title: "Download Failed",
        description: "Could not initiate download. This might be due to browser security settings (try using HTTPS) or browser incompatibility.",
        variant: "destructive",
      });
    }
  };

  const downloadAllAsZip = async () => {
    if (faviconResults.length === 0) {
      toast({ title: "No Files", description: "Generate favicons first.", variant: "warning" })
      return
    }

    setIsProcessing(true)
    setProcessingProgress({ current: 0, total: faviconResults.length + 3, stage: "Preparing ZIP...", percentage: 0 })

    try {
      const JSZip = (await import("jszip")).default
      const zip = new JSZip()

      // Add favicon files with better error handling
      for (let i = 0; i < faviconResults.length; i++) {
        const result = faviconResults[i]
        if (!result) continue

        setProcessingProgress({
          current: i + 1,
          total: faviconResults.length + 3,
          stage: `Adding ${result.name}...`,
          percentage: Math.round(((i + 1) / (faviconResults.length + 3)) * 100),
        })

        try {
          const response = await fetch(result.url)
          if (!response.ok) throw new Error(`Failed to fetch ${result.name}`)
          const blob = await response.blob()
          zip.file(result.name, blob)
        } catch (fetchError: any) {
          console.error(`Error adding ${result.name}:`, fetchError)
          // Continue with other files instead of failing completely
        }
      }

      // Add HTML and manifest
      zip.file("favicon_html.html", htmlCode)
      zip.file("manifest.json", manifestContent)

      const readmeContent = `Favicon Package - Generated by CognifyTech Favicon Generator
    
Visit: https://cognifytech.in/tool

Installation Instructions:
1. Upload all favicon files to your website's root directory
2. Copy the HTML code from favicon_html.html into your <head> section
3. Upload manifest.json to your root directory

Generated on: ${new Date().toLocaleString()}
Total files: ${faviconResults.length}
`
      zip.file("README.txt", readmeContent)

      setProcessingProgress({
        current: faviconResults.length + 3,
        total: faviconResults.length + 3,
        stage: "Creating ZIP...",
        percentage: 95,
      })

      // Generate ZIP with compression for mobile compatibility
      const zipBlob = await zip.generateAsync({
        type: "blob",
        compression: "DEFLATE",
        compressionOptions: { level: 6 },
      })

      // Improved mobile-friendly download
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
      const zipUrl = URL.createObjectURL(zipBlob)

      if (isMobile) {
        // For mobile, try to open in new tab first
        const newWindow = window.open(zipUrl, "_blank")
        if (!newWindow) {
          // Fallback to download link
          const link = document.createElement("a")
          link.href = zipUrl
          link.download = "favicon-package.zip"
          link.target = "_blank"
          document.body.appendChild(link)
          link.click()
          document.body.removeChild(link)
        }
      } else {
        downloadFile(zipUrl, "favicon-package.zip")
      }

      toast({ title: "ZIP Ready!", description: "Favicon package created successfully." })

      // Clean up after delay
      setTimeout(() => URL.revokeObjectURL(zipUrl), 5000)
    } catch (error: any) {
      console.error("ZIP creation failed:", error)
      toast({
        title: "ZIP Creation Failed",
        description: "Please try downloading individual files instead.",
        variant: "destructive",
      })
    } finally {
      setIsProcessing(false)
      setProcessingProgress(null)
    }
  }

  const applyTemplate = (template: FaviconTemplate) => {
    // setSelectedTemplate(template); // UI state
    setProcessingOptions((prev) => ({
      ...prev,
      backgroundColor: template.colors[0],
      borderColor: template.colors[1] || INITIAL_PROCESSING_OPTIONS.borderColor,
    }))
    setAppConfig((prev) => ({ ...prev, themeColor: template.colors[0] || prev.themeColor }))
    setShowTemplateGallery(false)
    toast({ title: `Template "${template.name}" Applied!`, description: "Styles updated." })
  }

  const handleResetImageAdjustments = () => {
    setProcessingOptions((prev) => ({
      ...prev,
      brightness: INITIAL_PROCESSING_OPTIONS.brightness,
      contrast: INITIAL_PROCESSING_OPTIONS.contrast,
      saturation: INITIAL_PROCESSING_OPTIONS.saturation,
      quality: INITIAL_PROCESSING_OPTIONS.quality,
    }))
    toast({ title: "Image adjustments reset." })
  }

  const PreviewPanel = () => (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center">
          <Eye className="w-5 h-5 mr-2" />
          Live Output Preview
        </CardTitle>
        <div className="flex gap-2 flex-wrap">
          {[
            { mode: "browser" as const, icon: Monitor, label: "Browser" },
            { mode: "mobile" as const, icon: Smartphone, label: "Mobile" },
            { mode: "bookmark" as const, icon: Bookmark, label: "Bookmark" },
            { mode: "search" as const, icon: Search, label: "Search" },
          ].map(({ mode, icon: Icon, label }) => (
            <Button
              key={mode}
              variant={previewMode === mode ? "default" : "outline"}
              size="sm"
              onClick={() => setPreviewMode(mode)}
            >
              <Icon className="w-4 h-4 mr-1" />
              {label}
            </Button>
          ))}
        </div>
      </CardHeader>
      <CardContent>
        {previewUrl ? (
          <div className="space-y-4">
            {previewMode === "browser" && (
              <div className="bg-muted/20 p-3 rounded-lg border">
                <div className="flex items-center space-x-1.5 bg-background p-2 rounded-t-md shadow-sm">
                  <div className="w-3 h-3 bg-red-400 rounded-full"></div>
                  <div className="w-3 h-3 bg-yellow-400 rounded-full"></div>
                  <div className="w-3 h-3 bg-green-400 rounded-full"></div>
                </div>
                <div className="bg-background p-3 flex items-center border-t-0 border rounded-b-md">
                  <img
                    src={previewUrl || "/placeholder.svg?width=16&height=16&query=favicon"}
                    alt="Favicon Preview"
                    className="w-4 h-4 mr-2"
                  />
                  <span className="text-sm truncate font-medium">{appConfig.name}</span>
                  <span className="ml-auto text-xs text-muted-foreground hidden sm:inline">
                    {appConfig.siteUrl.replace(/^https?:\/\//, "")}
                  </span>
                </div>
              </div>
            )}
            {previewMode === "mobile" && (
              <div className="bg-muted/20 p-4 rounded-lg border max-w-xs mx-auto">
                <div className="bg-background rounded-lg p-3 shadow-sm">
                  <img
                    src={previewUrl || "/placeholder.svg?width=48&height=48&query=mobile+icon"}
                    alt="Mobile Icon"
                    className="w-12 h-12 rounded-lg mx-auto mb-2"
                  />
                  <p className="text-xs text-center font-medium truncate">{appConfig.name}</p>
                </div>
              </div>
            )}
            {previewMode === "bookmark" && (
              <div className="bg-muted/20 p-3 rounded-lg border">
                <div className="flex items-center space-x-3 bg-background p-2 rounded">
                  <img
                    src={previewUrl || "/placeholder.svg?width=16&height=16&query=bookmark"}
                    alt="Bookmark Icon"
                    className="w-4 h-4"
                  />
                  <span className="text-sm font-medium">{appConfig.name}</span>
                </div>
              </div>
            )}
            {previewMode === "search" && (
              <div className="bg-muted/20 p-3 rounded-lg border">
                <div className="bg-background p-3 rounded">
                  <div className="flex items-start space-x-3">
                    <img
                      src={previewUrl || "/placeholder.svg?width=16&height=16&query=search+result"}
                      alt="Search Result Icon"
                      className="w-4 h-4 mt-0.5"
                    />
                    <div className="min-w-0">
                      <h3 className="text-sm font-medium text-blue-600">{appConfig.name}</h3>
                      <p className="text-xs text-green-600 truncate">{appConfig.siteUrl}</p>
                      <p className="text-xs text-muted-foreground mt-1 line-clamp-2">{appConfig.description}</p>
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
        ) : (
          <div className="text-center text-muted-foreground py-8">
            {sourceCanvas ? "Adjust settings for preview" : "Upload image for preview"}
          </div>
        )}
      </CardContent>
    </Card>
  )

  const NextButton = ({ label, disabled }: { label: string; disabled?: boolean }) => (
    <div className="mt-6 flex justify-end">
      <Button onClick={handleNextTab} disabled={disabled || !sourceCanvas} size="lg">
        {label} <ArrowRight className="w-4 h-4 ml-2" />
      </Button>
    </div>
  )

  return (
    <div className="space-y-6">
      <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
        <TabsList className="flex w-full overflow-x-auto p-1 sm:grid sm:grid-cols-5 sm:overflow-x-hidden">
          <TabsTrigger value="upload" className="flex-shrink-0 sm:flex-shrink-1">
            1. Upload
          </TabsTrigger>
          <TabsTrigger value="customize" disabled={!sourceCanvas} className="flex-shrink-0 sm:flex-shrink-1">
            2. Customize
          </TabsTrigger>
          <TabsTrigger value="generate" disabled={!sourceCanvas} className="flex-shrink-0 sm:flex-shrink-1">
            3. Generate
          </TabsTrigger>
          <TabsTrigger
            value="download"
            disabled={faviconResults.length === 0}
            className="flex-shrink-0 sm:flex-shrink-1"
          >
            4. Download
          </TabsTrigger>
        </TabsList>

        <TabsContent value="upload" className="space-y-6">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center">
                  <UploadCloud className="w-6 h-6 mr-2 text-primary" />
                  Upload Image
                </CardTitle>
                <CardDescription>Supports PNG, JPG, SVG, WebP. Max 10MB. Square images recommended.</CardDescription>
              </CardHeader>
              <CardContent>
                <div
                  className={`border-2 border-dashed rounded-lg p-8 text-center transition-colors ${isDraggingOverFile ? "border-primary bg-primary/10" : "border-muted-foreground/25 hover:border-primary/50"}`}
                  onDrop={handleDrop}
                  onDragOver={handleDragOver}
                  onDragLeave={handleDragLeave}
                >
                  <UploadCloud className="w-12 h-12 mx-auto mb-4 text-muted-foreground" />
                  <p className="text-lg font-medium mb-2">
                    {isDraggingOverFile ? "Drop image here" : "Drag & drop image"}
                  </p>
                  <p className="text-muted-foreground mb-4">or</p>
                  <Button
                    onClick={() => fileInputRef.current?.click()}
                    className="bg-primary hover:bg-primary/90 text-primary-foreground"
                  >
                    <UploadCloud className="w-4 h-4 mr-2" />
                    Select File
                  </Button>
                  <input
                    ref={fileInputRef}
                    type="file"
                    accept="image/png, image/jpeg, image/svg+xml, image/webp"
                    className="hidden"
                    onChange={(e) => e.target.files?.[0] && handleFileUpload(e.target.files[0])}
                  />
                </div>
                {isProcessing && processingProgress && processingProgress.stage.includes("Loading") && (
                  <div className="mt-4">
                    <Progress value={processingProgress.percentage} className="w-full" />
                    <p className="text-sm text-muted-foreground mt-2 text-center">
                      {processingProgress.stage} ({processingProgress.percentage}%)
                    </p>
                  </div>
                )}
              </CardContent>
            </Card>
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center">
                  <Grid className="w-5 h-5 mr-2" />
                  Template Gallery
                </CardTitle>
                <CardDescription>Quick start with a pre-designed style.</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="grid grid-cols-2 gap-3 mb-4">
                  {FAVICON_TEMPLATES.slice(0, 4).map((template) => (
                    <div
                      key={template.id}
                      className="border rounded-lg p-3 cursor-pointer hover:border-primary transition-colors"
                      onClick={() => applyTemplate(template)}
                      title={`Apply ${template.name} template`}
                    >
                      <div
                        className="w-12 h-12 rounded-lg mx-auto mb-2 flex items-center justify-center text-white text-2xl font-bold"
                        style={{
                          background: `linear-gradient(135deg, ${template.colors[0]}, ${template.colors[1] || template.colors[0]})`,
                        }}
                      >
                        {template.name.substring(0, 1)}
                      </div>
                      <p className="text-xs font-medium text-center truncate">{template.name}</p>
                      <p className="text-xs text-muted-foreground text-center">{template.category}</p>
                    </div>
                  ))}
                </div>
                <Dialog open={showTemplateGallery} onOpenChange={setShowTemplateGallery}>
                  <DialogTrigger asChild>
                    <Button variant="outline" className="w-full">
                      <FolderOpen className="w-4 h-4 mr-2" />
                      Browse All Templates
                    </Button>
                  </DialogTrigger>
                  <DialogContent className="max-w-4xl max-h-[80vh]">
                    <DialogHeader>
                      <DialogTitle>Template Gallery</DialogTitle>
                      <DialogDescription>Choose a template to apply its color scheme.</DialogDescription>
                    </DialogHeader>
                    <ScrollArea className="h-96 pr-3">
                      <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
                        {FAVICON_TEMPLATES.map((template) => (
                          <Card
                            key={template.id}
                            className="cursor-pointer hover:shadow-lg transition-shadow"
                            onClick={() => applyTemplate(template)}
                          >
                            <CardContent className="p-4">
                              <div
                                className="w-16 h-16 rounded-lg mx-auto mb-3 flex items-center justify-center text-white text-3xl font-bold"
                                style={{
                                  background: `linear-gradient(135deg, ${template.colors[0]}, ${template.colors[1] || template.colors[0]})`,
                                }}
                              >
                                {template.name.substring(0, 1)}
                              </div>
                              <h3 className="font-medium text-sm text-center">{template.name}</h3>
                              <p className="text-xs text-muted-foreground text-center mb-2">{template.description}</p>
                              <div className="flex gap-1 mt-2 justify-center">
                                {template.colors.slice(0, 3).map((color, idx) => (
                                  <div
                                    key={idx}
                                    className="w-4 h-4 rounded-full border"
                                    style={{ backgroundColor: color }}
                                    title={color}
                                  />
                                ))}
                              </div>
                            </CardContent>
                          </Card>
                        ))}
                      </div>
                    </ScrollArea>
                  </DialogContent>
                </Dialog>
              </CardContent>
            </Card>
          </div>
          <NextButton label="Next: Customize" />
        </TabsContent>

        <TabsContent value="customize" className="space-y-6">
          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div className="lg:col-span-2 space-y-6">
              {sourceCanvas && (
                <Card>
                  <CardHeader>
                    <CardTitle className="flex items-center">
                      <CropIcon className="w-5 h-5 mr-2" /> Image Crop
                    </CardTitle>
                    <CardDescription>Drag selection to move, or edges/corners to resize.</CardDescription>
                  </CardHeader>
                  <CardContent className="space-y-4">
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      <div>
                        <Label className="text-sm font-medium mb-2 block">Crop Selection</Label>
                        <div
                          className="flex justify-center items-center bg-muted/20 p-2 rounded-md border touch-none select-none relative overflow-hidden"
                          onMouseDown={handleCropMouseDown}
                          onTouchStart={handleCropTouchStart}
                          onMouseMove={handleCropCanvasMouseMoveForCursor}
                          style={{ cursor: currentCursor, minHeight: "200px" }}
                        >
                          <canvas ref={cropSelectionCanvasRef} className="max-w-full max-h-[300px] rounded-md" />
                        </div>
                      </div>
                      <div>
                        <Label className="text-sm font-medium mb-2 block">Crop Preview</Label>
                        <div className="flex justify-center items-center bg-muted/20 p-2 rounded-md border min-h-[200px]">
                          <canvas ref={cropPreviewCanvasRef} className="rounded-md border" />
                        </div>
                      </div>
                    </div>
                    <div className="space-y-3 p-3 border rounded-md">
                      <h4 className="text-sm font-medium mb-2">Crop Settings (pixels)</h4>
                      <div className="grid grid-cols-2 sm:grid-cols-4 gap-3">
                        <div>
                          <Label htmlFor="rectX">X</Label>
                          <Input
                            id="rectX"
                            type="number"
                            inputMode="numeric"
                            value={Math.round(cropRectangleSettings.x)}
                            onChange={(e) => handleRectangleCropChange("x", e.target.value)}
                            className="mt-1"
                          />
                        </div>
                        <div>
                          <Label htmlFor="rectY">Y</Label>
                          <Input
                            id="rectY"
                            type="number"
                            inputMode="numeric"
                            value={Math.round(cropRectangleSettings.y)}
                            onChange={(e) => handleRectangleCropChange("y", e.target.value)}
                            className="mt-1"
                          />
                        </div>
                        <div>
                          <Label htmlFor="rectW">Width</Label>
                          <Input
                            id="rectW"
                            type="number"
                            inputMode="numeric"
                            value={Math.round(cropRectangleSettings.width)}
                            onChange={(e) => handleRectangleCropChange("width", e.target.value)}
                            className="mt-1"
                          />
                        </div>
                        <div>
                          <Label htmlFor="rectH">Height</Label>
                          <Input
                            id="rectH"
                            type="number"
                            inputMode="numeric"
                            value={Math.round(cropRectangleSettings.height)}
                            onChange={(e) => handleRectangleCropChange("height", e.target.value)}
                            className="mt-1"
                          />
                        </div>
                      </div>
                      <div>
                        <Label htmlFor="rectRadius">
                          Corner Radius: {Math.round(cropRectangleSettings.cornerRadius)}px
                        </Label>
                        <Slider
                          id="rectRadius"
                          value={[cropRectangleSettings.cornerRadius]}
                          onValueChange={([v]) => handleRectangleCropChange("cornerRadius", v)}
                          max={
                            sourceCanvas ? Math.min(cropRectangleSettings.width, cropRectangleSettings.height) / 2 : 50
                          }
                          min={0}
                          step={1}
                          className="mt-2"
                        />
                      </div>
                    </div>
                    <Button variant="outline" size="sm" className="w-full" onClick={resetCropToFullImageDimensions}>
                      <RefreshCcw className="w-4 h-4 mr-2" /> Reset Crop
                    </Button>
                  </CardContent>
                </Card>
              )}
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center">
                    <Palette className="w-5 h-5 mr-2" /> Colors & Style
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                  <div className="flex items-center justify-between">
                    <Label htmlFor="enableBackgroundColor">Enable Background Color</Label>
                    <Checkbox
                      id="enableBackgroundColor"
                      checked={hasBackgroundColor}
                      onCheckedChange={(checked) => setHasBackgroundColor(Boolean(checked))}
                    />
                  </div>
                  {hasBackgroundColor && (
                    <div>
                      <Label>Background Color</Label>
                      <div className="flex items-center space-x-2 mt-1">
                        <Input
                          type="color"
                          value={processingOptions.backgroundColor}
                          onChange={(e) =>
                            setProcessingOptions((prev) => ({ ...prev, backgroundColor: e.target.value }))
                          }
                          className="w-12 h-10 p-1"
                        />
                        <Input
                          type="text"
                          value={processingOptions.backgroundColor}
                          onChange={(e) =>
                            setProcessingOptions((prev) => ({ ...prev, backgroundColor: e.target.value }))
                          }
                          placeholder="#FFFFFF or transparent"
                          className="flex-1"
                        />
                      </div>
                    </div>
                  )}
                  <div className="flex items-center justify-between">
                    <Label>Add Border to Frame</Label>
                    <Checkbox
                      checked={processingOptions.hasBorder}
                      onCheckedChange={(checked) =>
                        setProcessingOptions((prev) => ({ ...prev, hasBorder: Boolean(checked) }))
                      }
                    />
                  </div>
                  {processingOptions.hasBorder && (
                    <div className="space-y-3 pl-4 border-l-2">
                      <div>
                        <Label>Border Color</Label>
                        <div className="flex items-center space-x-2 mt-1">
                          <Input
                            type="color"
                            value={processingOptions.borderColor}
                            onChange={(e) => setProcessingOptions((prev) => ({ ...prev, borderColor: e.target.value }))}
                            className="w-12 h-10 p-1"
                          />
                          <Input
                            type="text"
                            value={processingOptions.borderColor}
                            onChange={(e) => setProcessingOptions((prev) => ({ ...prev, borderColor: e.target.value }))}
                            className="flex-1"
                          />
                        </div>
                      </div>
                      <div>
                        <Label>Border Width: {processingOptions.borderWidth}px</Label>
                        <Slider
                          value={[processingOptions.borderWidth || 1]}
                          onValueChange={([value]) => setProcessingOptions((prev) => ({ ...prev, borderWidth: value }))}
                          max={10}
                          min={1}
                          step={1}
                          className="mt-2"
                        />
                      </div>
                    </div>
                  )}
                  <div>
                    <Label htmlFor="outputBorderRadiusSlider">
                      Frame Radius ({Math.round(processingOptions.borderRadius || 0)}px)
                    </Label>
                    <Slider
                      id="outputBorderRadiusSlider"
                      value={[processingOptions.borderRadius || 0]}
                      onValueChange={([value]) => setProcessingOptions((prev) => ({ ...prev, borderRadius: value }))}
                      max={64}
                      min={0}
                      step={1}
                      className="mt-2"
                      disabled={
                        cropRectangleSettings.cornerRadius >=
                        Math.min(cropRectangleSettings.width, cropRectangleSettings.height) / 2 - 0.01
                      }
                    />
                    {cropRectangleSettings.cornerRadius >=
                      Math.min(cropRectangleSettings.width, cropRectangleSettings.height) / 2 - 0.01 && (
                      <p className="text-xs text-muted-foreground mt-1">Frame circular due to crop.</p>
                    )}
                  </div>
                  <div>
                    <Label>Output Format</Label>
                    <Select
                      value={processingOptions.format}
                      onValueChange={(value: "png" | "webp" | "jpeg" | "ico") =>
                        setProcessingOptions((prev) => ({ ...prev, format: value }))
                      }
                    >
                      <SelectTrigger className="mt-1">
                        <SelectValue placeholder="Select format" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="png">PNG</SelectItem>
                        <SelectItem value="webp">WebP</SelectItem>
                        <SelectItem value="jpeg">JPEG</SelectItem>
                        <SelectItem value="ico">ICO</SelectItem>
                      </SelectContent>
                    </Select>
                    <p className="text-xs text-muted-foreground mt-1">`favicon.ico` always ICO.</p>
                  </div>
                </CardContent>
              </Card>
            </div>
            <div className="lg:col-span-1 space-y-6">
              <PreviewPanel />
            </div>
          </div>
          <NextButton label="Next: Generate" />
        </TabsContent>

        <TabsContent value="generate" className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center">
                <Zap className="w-5 h-5 mr-2" />
                Select Sizes & Generate
              </CardTitle>
              <CardDescription>Recommended sizes pre-selected.</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                {COMPREHENSIVE_FAVICON_SIZES.map((sizeInfo) => (
                  <div
                    key={sizeInfo.size}
                    className="flex items-start space-x-3 p-3 border rounded-lg hover:border-primary/50 transition-colors"
                  >
                    <Checkbox
                      id={`size-${sizeInfo.size}`}
                      checked={selectedSizes.includes(sizeInfo.size)}
                      onCheckedChange={(checked) => handleSizeToggle(sizeInfo.size, Boolean(checked))}
                      className="mt-1 flex-shrink-0"
                    />
                    <div className="flex-1 min-w-0">
                      <Label
                        htmlFor={`size-${sizeInfo.size}`}
                        className="flex flex-wrap items-center gap-x-2 cursor-pointer"
                      >
                        <span className="font-medium">{sizeInfo.label}</span>
                        {sizeInfo.recommended && (
                          <Badge variant="secondary" className="text-xs whitespace-nowrap">
                            Recommended
                          </Badge>
                        )}
                        <Badge variant="outline" className="text-xs whitespace-nowrap capitalize">
                          {sizeInfo.type}
                        </Badge>
                      </Label>
                      <p className="text-xs text-muted-foreground mt-1">{sizeInfo.description}</p>
                    </div>
                  </div>
                ))}
              </div>
              <div className="mt-6 pt-6 border-t">
                <div className="flex flex-col sm:flex-row items-center justify-between mb-4 gap-4 sm:gap-2">
                  <div>
                    <p className="font-medium text-center sm:text-left">Selected: {selectedSizes.length} sizes</p>
                  </div>
                  <div className="flex flex-col sm:flex-row gap-2 w-full sm:w-auto">
                    <Button
                      variant="outline"
                      onClick={() =>
                        setSelectedSizes(COMPREHENSIVE_FAVICON_SIZES.filter((s) => s.recommended).map((s) => s.size))
                      }
                      className="w-full sm:w-auto"
                    >
                      Select Recommended
                    </Button>
                    <Button
                      variant="outline"
                      onClick={() => setSelectedSizes(COMPREHENSIVE_FAVICON_SIZES.map((s) => s.size))}
                      className="w-full sm:w-auto"
                    >
                      Select All
                    </Button>
                    <Button variant="outline" onClick={() => setSelectedSizes([])} className="w-full sm:w-auto">
                      Deselect All
                    </Button>
                  </div>
                </div>
                <Button
                  onClick={handleGenerate}
                  disabled={isProcessing || selectedSizes.length === 0 || !sourceCanvas}
                  className="w-full bg-green-600 hover:bg-green-700 text-white"
                  size="lg"
                >
                  {isProcessing && processingProgress ? (
                    <>
                      <Settings className="w-5 h-5 mr-2 animate-spin" />
                      {processingProgress.stage} ({processingProgress.percentage}%)
                    </>
                  ) : (
                    <>
                      <Zap className="w-5 h-5 mr-2" />
                      Generate {selectedSizes.length} Favicon{selectedSizes.length !== 1 ? "s" : ""}
                    </>
                  )}
                </Button>
                {isProcessing && processingProgress && (
                  <div className="mt-4">
                    <Progress value={processingProgress.percentage} className="w-full" />
                  </div>
                )}
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="download" className="space-y-6">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center justify-between">
                  <div className="flex items-center">
                    <Download className="w-5 h-5 mr-2" />
                    Generated Files
                  </div>
                  <Badge variant="secondary">{faviconResults.length} files</Badge>
                </CardTitle>
                <CardDescription>
                  Total size: {(faviconResults.reduce((sum, r) => sum + (r?.bytes || 0), 0) / 1024).toFixed(1)} KB
                </CardDescription>
              </CardHeader>
              <CardContent>
                <ScrollArea className="h-64 pr-3">
                  <div className="space-y-2">
                    {faviconResults.map(
                      (result, index) =>
                        result && (
                          <div
                            key={index}
                            className="flex items-center justify-between p-3 border rounded-lg hover:shadow-sm"
                          >
                            <div className="flex items-center space-x-3 min-w-0">
                              <img
                                src={result.url || "/placeholder.svg?width=32&height=32&query=icon"}
                                alt={result.name}
                                className="w-8 h-8 object-contain border rounded-sm bg-slate-100 dark:bg-slate-800"
                              />
                              <div className="min-w-0">
                                <p className="font-medium text-sm truncate">{result.name}</p>
                                <p className="text-xs text-muted-foreground">
                                  {result.size}  {(result.bytes / 1024).toFixed(1)} KB{" "}
                                  {result.optimized && <span className="text-green-600 ml-1"> Optimized</span>}
                                </p>
                              </div>
                            </div>
                            <Button
                              size="sm"
                              variant="ghost"
                              onClick={() => downloadFile(result.url, result.name)}
                              className="flex-shrink-0 ml-2"
                              title={`Download ${result.name}`}
                            >
                              <Download className="w-4 h-4" />
                            </Button>
                          </div>
                        ),
                    )}
                  </div>
                </ScrollArea>
                <div className="mt-4 space-y-2">
                  <Button
                    className="w-full"
                    size="lg"
                    onClick={downloadAllAsZip}
                    disabled={isProcessing || faviconResults.length === 0}
                  >
                    {isProcessing && processingProgress && processingProgress.stage.includes("ZIP") ? (
                      <>
                        <Settings className="w-5 h-5 mr-2 animate-spin" />
                        {processingProgress.stage} ({processingProgress.percentage}%)
                      </>
                    ) : (
                      <>
                        <Package className="w-5 h-5 mr-2" />
                        Download All as ZIP
                      </>
                    )}
                  </Button>
                  <p className="text-xs text-muted-foreground text-center">Includes icons, HTML, and manifest.</p>
                </div>
              </CardContent>
            </Card>
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center justify-between">
                  <div className="flex items-center">
                    <Code className="w-5 h-5 mr-2" />
                    HTML Code Snippet
                  </div>
                  <Button size="sm" variant="outline" onClick={() => copyToClipboard(htmlCode, "HTML Code")}>
                    {copied ? <Check className="w-4 h-4 text-green-500" /> : <Copy className="w-4 h-4" />}
                  </Button>
                </CardTitle>
                <CardDescription>Paste into {"<head>"} of your HTML.</CardDescription>
              </CardHeader>
              <CardContent>
                <ScrollArea className="h-48">
                  <pre className="text-xs bg-muted p-3 rounded-md overflow-x-auto">
                    <code>{htmlCode}</code>
                  </pre>
                </ScrollArea>
              </CardContent>
            </Card>
          </div>
        </TabsContent>
      </Tabs>
    </div>
  )
}
export default ProfessionalFaviconGenerator
